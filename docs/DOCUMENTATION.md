# Quokka Documentation

This document outlines formally the language grammar and the functioning of the different steps of the intepreter.  

For the documentation of language features see [FEATURES](./FEATURES.md).

*See the [README](../README.md) for up to date list of features to be implemented.*

## Lexer

> Lexer documentation outdated

Parses the string of the input file and tokenizes it into the following sets

```
IDENTIFIER : {a-z}+
NUMBER     : {0..9}+
OPERATOR   : {+,-,*,/}
ASSIGNMENT : {=}
SEMI-COLON : {;}
```

## Parser

Builds an Abstract Syntax Tree (AST) using recursive descent parsing with precedence climbing.  

Defined by the following context free grammar:

```
program        = { statement SEPERATOR } ;

statement      = expression
               | block ;

block          = BRACES_L { statement SEPERATOR } BRACES_R ;

expression     = assignment
               | function_definition
               | class_definition
               | set_expression
               | while_statement
               | for_statement
               | if_statement
               | return_statement
               | out_statement
               | in_statement
               | increment_expression
               | compound_assignment
               | logical_expression ;

assignment     = term ASSIGNMENT expression ;

set_expression = SET term ASSIGNMENT expression ;

function_definition = DEF expression FUNCTION block ;

class_definition = CLASS identifier block ;

while_statement = WHILE expression DO block ;

for_statement   = FOR expression SEPERATOR expression SEPERATOR expression SEPERATOR block ;

if_statement    = IF expression DO block [ ELSE block ] ;

return_statement = RETURN expression ;

out_statement    = OUT expression ;

in_statement     = IN ;

increment_expression = identifier (OP_ADD_ADD | OP_SUB_SUB) ;

compound_assignment = identifier compound_operator expression ;
compound_operator   = "+=" | "-=" | "*=" | "/=" ;

logical_expression = relation { (OP_AND | OP_OR) relation } ;
relation           = addition { (OP_EQ | OP_NEQ | OP_LT | OP_LTE | OP_GT | OP_GTE) addition } ;
addition           = multiply { (OP_ADD | OP_SUB) multiply } ;
multiply           = term { (OP_MUL | OP_DIV) term } ;

term               = OP_NOT term
                   | literal
                   | identifier
                   | PAREN_L expression PAREN_R ;

literal            = LITERAL | FLOAT | STRING | TRUE | FALSE ;

identifier         = IDENTIFIER [ arguments ] ;
arguments          = PAREN_L [ expression { COMMA expression } ] PAREN_R ;

```

## Evaluator

The evaluator is the runtime interpreter for the language. It traverses the abstract syntax tree (AST) generated by the parser and computes the corresponding values or executes statements.